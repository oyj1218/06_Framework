# Framework vs Library

프레임워크 : 재료까지 준비된 밀키트 느낌

라이브러리는 : 재료는 내가 준비해야 하는 레시피 느낌

제어의 역전개념이 적용된 대표적인 기술 : 객체를 따로 만들어주지 않음

→ 개발자가 신경쓸 게 많이 없어진다

servlet, jdbc 등으로 여러 단계로 왔다갔다 한 게 많이 없어짐

라이브러리가 많이 뭉치면 프레임워크 느낌도 나옴

A 라이브러리 + B 라이브러리 이거 2개 잘 연결하면 괜찮겠는데? 프레임워크가 되기도 함

애플리케이션 흐름을 누가 쥐고 있는가가 다름

지금까지 우리가 만들었지만 프레임워크가 이제 제공해줄 예정

1. 개발자가 따라야 하는 가이드를 제공한다
2. 개발할 수 있는 범위가 정해져 있다
3. 개발자를 위한 다양한 도구, 플러그인들을 지원한다


💡 프레임워크(ex. 스프링)는 범위가 정해져 있음
→ 스프링의 경우, 자바에 국한되어 있음



**프레임워크 특징**

**장점**

1. 개발 시간을 줄일 수 있음
2. 정형화 되어 있어 일정수준 이상 품질을 기대할 수 있음
3. 유지보수가 쉽다

**단점**

1. 너무 의존하면 개발자들의 능력 떨어져서 스스로 직접 개발하는 것이 어려워짐
2. 습득 시간이 오래 걸림

**프레임워크 종류**

1. 영속성(지속 가능한 성질) : 

그동안 JDBC로 했는데, 이젠 Mybatis & Hibernate로 사용하면 JDBC에서 번거로웠던 걸 끝냄

1. 자바 : 

스프링 & 전자정부표준 스프링 - 다른 거 아님

1. 화면 구현 : Bootstrap

프론트엔드 쉽게 쉽게 만들 수 있게 함

1. 기능 및 지원 : 
Log4j : 우리가 했던 syso 이런거 대신에 함 서버 켰을 때 빨간색으로 찍었던거 그런걸로 나오는 것

# 스프링 프레임워크

동적 웹 사이트를 위한 여러 가지 서비스 제공

MVC 기반으로 사용하고 있다

## 스프링 특징

특히 IOC, DI, POJO 기반 프레임워크, Spring AOP 중요하다

1. **IOC(제어 반전) :** 

개발자              -              프레임워크

new 객체()

원래는 객체 만들려면 개발자가 객체를 만들었는데

제어반전!! 프레임워크가 직접 관리한다!

개발자가 new로 만들지 않는다!!

프레임워크가 new 객체()로 생성한다

개발자가 객체 만들 때마다 heap 메모리를 사용했는데 → 관리가 어려움

근데 프레임워크는 컴퓨터이니 관리까지 알아서 메모리 관리를 해줌

개발자           프레임워크

Object            new 객체()

Instance         Bean

그럼 개발자가 만든 객체랑 프레임워크가 만든 객체를 어떻게 구분?

**❗프레임워크 객체 이름을 Bean이라고 부름❗**

Object, Instance, Bean 모두 다 객체인데

이름을 다르게 해서 구분해준 것

1. **DI**

개발자

@(어노테이션)여기로 주입해줘!

근데 new를 안 쓰잖아!

@Service service;

service라는 주소에 넣어줘

주입 : 프레임워크에 의존해서 주입을 받는다

= DI(의존성 주입)

그래서 IOC랑 DI는 서로 짝꿍이다

치킨 먹고 싶으면 치킨을 만드는게 아니라 배달을 통해 시키는 것처럼 배달주소 적는게 @

1. **POJO 기반 프레임워크** 

서블릿을 쓸 때 extends Https를 썼는데 이거는 의존도가 높은 것

근데 이젠 더이상 이렇게 쓰지 않기에

코드길이 감소, 유지보수성 증가, 기존 Java API, 라이브러리 지원에 용이

1. Spring AOP

관점지향프로그래밍

요청

Controller 

Service

DAO

DB

이 과정에서 주로 Service에 트랜잭션 개입한다

1. **PSA** : 다른 여러 모듈을 사용함에 있어 별도 추상화 레이어를 제공한다

구체적이지 않다, 모두 다 가능하다

@ : Controller 어노테이션도 있고, Service 어노테이션 등 굉장히 많다

스프링에서 쉽게 쓸 수 있게 추상화된 레이어를 제공한다

다른 모듈들을 알아서 쓸 수 있게 제어해준다

Handler Mapping

View REsolver, View

가 추가되었지만 기본적인 흐름은 동일하다


Dispatcher Servlet(발송자 서블릿) : 요청을 컨트롤러로 전달 + 응답
중앙처리 느낌인데, 우리가 만들지 않고 spring이 만들어준다

Handler Mapping(매핑 처리) : 어떤 요청을 어떤 클래스/메소드로 연결할 지 제어하는 객체

View Resolver(뷰 해결사) : Controller에서 반환된 문자열(”common/main”)
앞, 뒤에 경로(/WEB-INF/views/), 확장자(.jsp)를 붙여 jsp 파일의 경로를 지정한 후 forward(요청 위임)을 하는 객체

파라미터 전달 방법 1 : HttpServletRequest 이용

근데 HttpServletRequest를 쓰면 spring 굳이 사용하는 이유가 없다!

→ 방법2

**오버로딩으로 파라미터 타입, 개수, 순서가 다르기에 사용가능하다**

파라미터 전달 방법 2 : @RequestParam 어노테이션 이용

이때 파라미터의 name속성값과 매개변수 명이 같으면 @RequestParam 생략 가능하다

근데 전달해야 하는 파라미터가 너무 많으면?

servlet 때는 객체 생성해서 만들어줌


💡 **@RequestMapping(value=”요청주소”, method=RequestMethod.Post) = @PostMapping**

파라미더 전달 방법 3 : @ModelAttribute 이용

DTO & VO 같이 사용하는 어노테이션

전달받은 파라미터 name 속성값 = DTO 필드명 자동으로 setter를 호출해서 필드에 세팅

이때, DTO에 기본생성자, setter가 필수


💡 @ModelAttribute로 필드 값이 세팅된 객체 = 커맨드 객체

